# kafka

从以下方面对kafka面试进行总结：基本原理架构/项目实践/生产者/消费者/协调者/存储层/控制器

# 基本原理架构

## 简单讲下什么是kafka[一句话概括/架构图]

- Partition: kafka分区模型 每个分区都是一个有序的独立的不可变的记录序列，新的消息会不断-的追加到序列末尾，分区的offset都是从0开始。kafka只能保证消息在单个分区的有序
- Offset：偏移量 通过offset+partition+topic可以定位到唯一一条消息
- broke：消息代理服务器 可以认为是一台独立的机器
- Topic：消息主题
- ConsumerGroup：消费者组
- ISR：副本冗余[正在和主副本保持同步的备份副本 只要ISR中还有一个节点是存活的就能保证消息不丢失 主副本和备份副本都有消息，主挂可切换副]
- AR: 所有副本[包含主副本和正在同步的副本]
- OSR:被踢出ISR的叫OSR,当同步进度追上 会重新加入ISR

![kafka整体框架](imgs\kafka整体框架.jpg)

![kafka整体框架2](imgs\kafka整体框架2.png)



## 消息队列选型

|  中间件  |     ActiveMQ     |              RabbitMQ              |      RocketMQ      |                           kafka                            |
| :------: | :--------------: | :--------------------------------: | :----------------: | :--------------------------------------------------------: |
| 开发语言 |       Java       |               erlang               |        Java        |                           Scala                            |
|  吞吐量  |       万级       |                万级                |       10万级       |                           10万级                           |
| 消费模式 |    pull+push     |             pull+push              |     pull+push      |                            pull                            |
|  时效性  |       ms级       |                us级                |        ms级        |                          ms级别内                          |
|  可用性  |   高(主从架构)   |            高(主从架构)            | 非常高(分布式架构) |                     非常高(分布式架构)                     |
|   特点   | 老牌MQ相对较成熟 | 功能完善，管理界面方便，且社区活跃 | 功能完备，扩展性佳 | 支持主要的MQ功能，日志采集场景以及有大数据业务需求可以选用 |

## ZK 在消息队列中的作用是什么

注册中心[作为共享存储保存了kafka集群和客户端的相关信息]

## kafka是如何保障高可用的

一般多机分布式部署 Kafka每个topic的partition有N个副本，其中N是topic的复制因子。Kafka通过多副本机制实现故障自动转移，当Kafka集群中一个Broker失效情况下仍然保证服务可用。

## kafka有那些消息模型

队列模型和发布订阅 kafka使用消费者组统一了上面2种消息模型。[队列1对1/订阅1对多]

## kafka为什么这么快

追加方式写入 producer层选择分区并行写入数据[避免全量消息提交到协调阶段在计算分区] 使用消息batch[消息批 减少通讯次数]

## kafka follower如何与leader同步数据/kafka节点之间消息如何备份的

leader也称为主副本 follower 也称为备份副本
 Producer在push消息到kafka时，先通过ZK找到对应Topic下Partition的主副本[leader]，Producer和leader建立联系发送消息，N个replicas中。其中一个replica为leader，其他都为follower，leader处理partition的所有读写请求，与此同时，follower会被动定期地去复制leader上的数据。

这种消息机制不能算完全的同步也不能算完全的异步

### ISR HW LEO 之间的关系/流转过程

1. ISR 正在主副本保持备份的副本
2. HW high wather高水位 一般指的是ISR中同步主副本的进度最慢的副本当前正在同步的消息的offset，在HW之前的消息都可以被消费者拉取到
3. LEO log end offset 当前主副本中正在写入的消息 一般是当前分区中最后一条消息的offset+1

当主副本有消息写入的时候,follower会主动向leader获取消息，每次读消息都会更新HW当HW大于等于LEO时候可以认为是同步完成，副本管理者会想producer报告ack确认消息保存成功。

![ISR HW LEO](imgs\ISR HW LEO.png)

# 项目实践

## ACK 0 -1 1分别代表什么

- [-1] 也就all 需要等待ISR中所有都同步完成
- 1 默认的只需要等待主副本同步完成即可
- 0 不确认就开始发送下一条消息

## kafka事务

kafka在较高版本上支持事务，但是我们使用的版本较低，且目前业务上无硬性需求。

## 消息队列丢失数据如何处理

这个问题可以分为三个方面 生产者 消费者 消息队列

- 生产者方面我们使用的异步回调的方式，在收到回调的时候若消息没有发送成功，我们会记录再次发送。
- 消费者 消费者的数据丢失可以认为是提交了offset但是数据处理失败了，我们使用的手动提交在处理成功后在提交offset  不会遇到这个问题。但是要注意消息处理时间不能过长，如果处理过长还没提交offset管理者可能会认为当前消费者下线从而触发reblance
- 消息队列数据丢失 我们在kafka配置了`ack = -1` 要求所有ISR都确认同步了消息才给producer发送ack 所以可以保证消息不会丢失。

## 生产者

### 生产者消息发送的几种方式

同步阻塞 异步非阻塞 [都是通过send方法实现的]

### 生产者如何为消息选取分区的

若消息没有设置key loadblance写入partition。如设置了key `murmur2(key) mod PartitionNum`

### 简单讲下生产者的工作流程

1. 主线程将消息封装到ProducerRecord[partition/key/value/key/时间戳]
2. client对ProducerRecord进行序列化
3. 根据分区策略确定分区[无key轮询有key murmur2(key) mod PartitionNum]
4. 将消息放入缓存区[每一个分区对应一个双端队列，] 由sender线程将一个批次的消息batch的消息发送到对应的broker

### 生产者如何批量的发送消息

**sender的作用：归类消息为每个目标节点建立一个请求**

sender线程并不真正发送客户端请求 sender线程会去遍历记录收集器中根据分区分好组的消息batches,将相同目标节点[NodeId]的batches的消息归类，为相同目标节点的[NodeId]创建一个请求发送消息。

1. 消息放入记录收集器时会按分区进行分组，存放到对应的batches，分区队列保存了即将发送消息的批记录。
2. sender线程可以使用单线程迭代

## 消费者

### 什么是管理者

管理者是消费者组中的概念,用于对同一个消费者组中的所有消费者进行协调。

### 什么是reblance

简单来说就是消费者消费消息出现不均衡，会通过reblance达到动态平衡的过程。通常有如下几个方面

- 消费者组订阅的主题发生变化
- 消费者消费的分区数量出现变化
- 消费者组中的消费者数量发生变化

### 消费者什么时候会再次加入消费者组

消费者只有在出现reblance的时候会出现再次加入消费者，分为如下步骤1.消费者准备好自身状态2.和协调者发送加入消费者组的请求3.成功加入消费者组，分配分区开始消费消息。

### 2种消费模式

消费模式可分为订阅模式和分配模式

- 订阅模式 消费者订阅指定主题，由协调者协调消费的分区
- 分配模式 由消费者指定消费的分区。此时协调者不参与

我们项目中有4个分区，使用的订阅模式 设置了4个消费者。每个消费者独立消费一个分区[由协调者安排]

## 交付语义

1. 精准一次
2. 至多一次
3. 至少一次